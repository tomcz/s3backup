// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package client

import (
	"sync"
)

// Ensure, that StoreStub does implement Store.
// If this is not the case, regenerate this file with moq.
var _ Store = &StoreStub{}

// StoreStub is a mock implementation of Store.
//
//	func TestSomethingThatUsesStore(t *testing.T) {
//
//		// make and configure a mocked Store
//		mockedStore := &StoreStub{
//			DownloadFileFunc: func(remotePath string, localPath string) (string, error) {
//				panic("mock out the DownloadFile method")
//			},
//			UploadFileFunc: func(remotePath string, localPath string, checksum string) error {
//				panic("mock out the UploadFile method")
//			},
//		}
//
//		// use mockedStore in code that requires Store
//		// and then make assertions.
//
//	}
type StoreStub struct {
	// DownloadFileFunc mocks the DownloadFile method.
	DownloadFileFunc func(remotePath string, localPath string) (string, error)

	// UploadFileFunc mocks the UploadFile method.
	UploadFileFunc func(remotePath string, localPath string, checksum string) error

	// calls tracks calls to the methods.
	calls struct {
		// DownloadFile holds details about calls to the DownloadFile method.
		DownloadFile []struct {
			// RemotePath is the remotePath argument value.
			RemotePath string
			// LocalPath is the localPath argument value.
			LocalPath string
		}
		// UploadFile holds details about calls to the UploadFile method.
		UploadFile []struct {
			// RemotePath is the remotePath argument value.
			RemotePath string
			// LocalPath is the localPath argument value.
			LocalPath string
			// Checksum is the checksum argument value.
			Checksum string
		}
	}
	lockDownloadFile sync.RWMutex
	lockUploadFile   sync.RWMutex
}

// DownloadFile calls DownloadFileFunc.
func (mock *StoreStub) DownloadFile(remotePath string, localPath string) (string, error) {
	if mock.DownloadFileFunc == nil {
		panic("StoreStub.DownloadFileFunc: method is nil but Store.DownloadFile was just called")
	}
	callInfo := struct {
		RemotePath string
		LocalPath  string
	}{
		RemotePath: remotePath,
		LocalPath:  localPath,
	}
	mock.lockDownloadFile.Lock()
	mock.calls.DownloadFile = append(mock.calls.DownloadFile, callInfo)
	mock.lockDownloadFile.Unlock()
	return mock.DownloadFileFunc(remotePath, localPath)
}

// DownloadFileCalls gets all the calls that were made to DownloadFile.
// Check the length with:
//
//	len(mockedStore.DownloadFileCalls())
func (mock *StoreStub) DownloadFileCalls() []struct {
	RemotePath string
	LocalPath  string
} {
	var calls []struct {
		RemotePath string
		LocalPath  string
	}
	mock.lockDownloadFile.RLock()
	calls = mock.calls.DownloadFile
	mock.lockDownloadFile.RUnlock()
	return calls
}

// UploadFile calls UploadFileFunc.
func (mock *StoreStub) UploadFile(remotePath string, localPath string, checksum string) error {
	if mock.UploadFileFunc == nil {
		panic("StoreStub.UploadFileFunc: method is nil but Store.UploadFile was just called")
	}
	callInfo := struct {
		RemotePath string
		LocalPath  string
		Checksum   string
	}{
		RemotePath: remotePath,
		LocalPath:  localPath,
		Checksum:   checksum,
	}
	mock.lockUploadFile.Lock()
	mock.calls.UploadFile = append(mock.calls.UploadFile, callInfo)
	mock.lockUploadFile.Unlock()
	return mock.UploadFileFunc(remotePath, localPath, checksum)
}

// UploadFileCalls gets all the calls that were made to UploadFile.
// Check the length with:
//
//	len(mockedStore.UploadFileCalls())
func (mock *StoreStub) UploadFileCalls() []struct {
	RemotePath string
	LocalPath  string
	Checksum   string
} {
	var calls []struct {
		RemotePath string
		LocalPath  string
		Checksum   string
	}
	mock.lockUploadFile.RLock()
	calls = mock.calls.UploadFile
	mock.lockUploadFile.RUnlock()
	return calls
}
