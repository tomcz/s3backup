// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package client

import (
	"sync"
)

// Ensure, that HashStub does implement Hash.
// If this is not the case, regenerate this file with moq.
var _ Hash = &HashStub{}

// HashStub is a stub implementation of Hash.
//
//	func TestSomethingThatUsesHash(t *testing.T) {
//
//		// make and configure a stubbed Hash
//		stubbedHash := &HashStub{
//			CalculateFunc: func(filePath string) (string, error) {
//				panic("stub out the Calculate method")
//			},
//			VerifyFunc: func(filePath string, expectedChecksum string) error {
//				panic("stub out the Verify method")
//			},
//		}
//
//		// use stubbedHash in code that requires Hash
//		// and then make assertions.
//
//	}
type HashStub struct {
	// CalculateFunc stubs the Calculate method.
	CalculateFunc func(filePath string) (string, error)

	// VerifyFunc stubs the Verify method.
	VerifyFunc func(filePath string, expectedChecksum string) error

	// calls tracks calls to the methods.
	calls struct {
		// Calculate holds details about calls to the Calculate method.
		Calculate []struct {
			// FilePath is the filePath argument value.
			FilePath string
		}
		// Verify holds details about calls to the Verify method.
		Verify []struct {
			// FilePath is the filePath argument value.
			FilePath string
			// ExpectedChecksum is the expectedChecksum argument value.
			ExpectedChecksum string
		}
	}
	lockCalculate sync.RWMutex
	lockVerify    sync.RWMutex
}

// Calculate calls CalculateFunc.
func (stub *HashStub) Calculate(filePath string) (string, error) {
	if stub.CalculateFunc == nil {
		panic("HashStub.CalculateFunc: method is nil but Hash.Calculate was just called")
	}
	callInfo := struct {
		FilePath string
	}{
		FilePath: filePath,
	}
	stub.lockCalculate.Lock()
	stub.calls.Calculate = append(stub.calls.Calculate, callInfo)
	stub.lockCalculate.Unlock()
	return stub.CalculateFunc(filePath)
}

// CalculateCalls gets all the calls that were made to Calculate.
// Check the length with:
//
//	len(stubbedHash.CalculateCalls())
func (stub *HashStub) CalculateCalls() []struct {
	FilePath string
} {
	var calls []struct {
		FilePath string
	}
	stub.lockCalculate.RLock()
	calls = stub.calls.Calculate
	stub.lockCalculate.RUnlock()
	return calls
}

// Verify calls VerifyFunc.
func (stub *HashStub) Verify(filePath string, expectedChecksum string) error {
	if stub.VerifyFunc == nil {
		panic("HashStub.VerifyFunc: method is nil but Hash.Verify was just called")
	}
	callInfo := struct {
		FilePath         string
		ExpectedChecksum string
	}{
		FilePath:         filePath,
		ExpectedChecksum: expectedChecksum,
	}
	stub.lockVerify.Lock()
	stub.calls.Verify = append(stub.calls.Verify, callInfo)
	stub.lockVerify.Unlock()
	return stub.VerifyFunc(filePath, expectedChecksum)
}

// VerifyCalls gets all the calls that were made to Verify.
// Check the length with:
//
//	len(stubbedHash.VerifyCalls())
func (stub *HashStub) VerifyCalls() []struct {
	FilePath         string
	ExpectedChecksum string
} {
	var calls []struct {
		FilePath         string
		ExpectedChecksum string
	}
	stub.lockVerify.RLock()
	calls = stub.calls.Verify
	stub.lockVerify.RUnlock()
	return calls
}
